(cl:in-package #:sicl-compiler)

(defun source-position-equal (p1 p2)
  (and (eql (sicl-source-tracking:line-index (car p1))
            (sicl-source-tracking:line-index (car p2)))
       (eql (sicl-source-tracking:line-index (cdr p1))
            (sicl-source-tracking:line-index (cdr p2)))
       (eql (sicl-source-tracking:character-index (car p1))
            (sicl-source-tracking:character-index (car p2)))
       (eql (sicl-source-tracking:character-index (cdr p1))
            (sicl-source-tracking:character-index (cdr p2)))
       (equalp (sicl-source-tracking:lines (car p1))
               (sicl-source-tracking:lines (car p2)))))

(defun call-entry-point (code-vector)
  ;; FIXME: define this function.
  (declare (ignore code-vector))
  nil)

(defun tie-code-object (client environment code-object)
  (let ((sicl-run-time:*dynamic-environment* '()))
    (loop for call-site in (call-sites code-object)
          for name = (name call-site)
          do (env:add-call-site client environment call-site name))
    (call-entry-point (instructions code-object))))
