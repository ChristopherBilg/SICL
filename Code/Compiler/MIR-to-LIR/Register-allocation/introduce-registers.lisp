(cl:in-package #:sicl-register-allocation)

(defun find-register-in-arrangement (arrangement datum)
  ;; Any datum that is not a lexical location does not need to be
  ;; replaced.
  (unless (typep datum 'cleavir-ir:lexical-location)
    (return-from find-register-in-arrangement datum))
  (multiple-value-bind (stack-slot register-number)
      (arr:find-attribution arrangement datum)
    (cond
      ((not (null register-number))
       (aref *registers* register-number))
      ;; Try to make a useful error...
      ((not (null stack-slot))
       (error "~S has an attributed stack slot but no attributed register.
Did you forget to call ENSURE-INPUT-AVAILABLE?"
              datum))
      (t
       (error "~S has no attribution." datum)))))

(defgeneric introduce-registers-for-instruction (instruction))

;;; For most instructions, it suffices to replace every lexical
;;; location with the registers attributed to them.
(defmethod introduce-registers-for-instruction
    ((instruction cleavir-ir:instruction))
  (let ((input-arrangement (input-arrangement instruction)))
      (setf (cleavir-ir:inputs instruction)
            (mapcar (lambda (input)
                      (find-register-in-arrangement input-arrangement
                                                    input))
                    (cleavir-ir:inputs instruction))))
  (let ((output-arrangement (output-arrangement instruction)))
    (setf (cleavir-ir:outputs instruction)
          (mapcar (lambda (output)
                    (find-register-in-arrangement output-arrangement
                                                  output))
                  (cleavir-ir:outputs instruction)))))

;;; An ENTER-INSTRUCTION only has outputs, and only the first two
;;; outputs (static and dynamic environment locations) are attributed.

(defmethod introduce-registers-for-instruction
    ((instruction cleavir-ir:enter-instruction))
  (let ((output-arrangement (output-arrangement instruction))
        (outputs (cleavir-ir:outputs instruction)))
    (setf (cleavir-ir:outputs instruction)
          (list* (find-register-in-arrangement output-arrangement
                                               (first outputs))
                 (find-register-in-arrangement output-arrangement
                                               (second outputs))
                 (nthcdr 2 outputs)))))

;;; Assignment instructions generated by SPILL and UNSPILL need to
;;; be converted to MEMSET2 and MEMREF2 instructions though.

;; Also, we should put the 8 bytes-per-word number somewhere in my
;; opinion.
(defconstant +stack-slot-size+ 8)

(defmethod introduce-registers-for-instruction
    ((instruction cleavir-ir:assignment-instruction))
  (let ((input  (first (cleavir-ir:inputs instruction)))
        (output (first (cleavir-ir:outputs instruction))))
    ;; Such assignments assign a lexical location to itself, so
    ;; any other assignments can be handled with the normal rule.
    (unless (and (eq input output)
                 (typep input 'cleavir-ir:lexical-location))
      (return-from introduce-registers-for-instruction
        (call-next-method)))
    (multiple-value-bind (in-stack in-register)
        (arr:find-attribution (input-arrangement instruction) input)
      (assert (not (and (null in-register)
                        (null in-stack)))
              ()
              "~S has no attribution in the input arrangement of ~S"
              input instruction)
      (multiple-value-bind (out-stack out-register)
          (arr:find-attribution (output-arrangement instruction) output)
        (assert (not (and (null out-register)
                          (null out-stack)))
              ()
              "~S has no attribution in the output arrangement of ~S"
              output instruction)
        (cond
          ((and (null in-stack) (not (null out-stack)))
           ;; This instruction is a spill.
           (change-class instruction 'cleavir-ir:memset2-instruction
             :inputs (list *rsp*
                           (* +stack-slot-size+ out-stack)
                           (aref *registers* in-register))
             :outputs '()))
          ((and (null in-register) (not (null out-register)))
           ;; This instruction is an unspill.
           (change-class instruction 'cleavir-ir:memref2-instruction
             :inputs (list *rsp* (* +stack-slot-size+ in-stack))
             :outputs (list (aref *registers* out-register))))
          ((and (not (null in-register)) (not (null in-register)))
           ;; This instruction is a plain register to register assignment.
           (setf (cleavir-ir:inputs instruction)
                 (aref *registers* in-register)
                 (cleavir-ir:outputs instruction)
                 (aref *registers* out-register)))
          (t
           (error "Not sure what the assignment of (~A, ~A) to (~A, ~A) is meant to be."
                  in-register in-stack out-register out-stack)))))))

;;; NOP-INSTRUCTIONs shouldn't have inputs and outputs, but we
;;; generate NOP-INSTRUCTIONs with inputs and outputs by CHANGE-CLASS
;;; somewhere.  So just ignore them until those are sniffed out.

(defmethod introduce-registers-for-instruction
    ((instruction cleavir-ir:nop-instruction))
  nil)

(defun introduce-registers (mir)
  (cleavir-ir:map-local-instructions
   #'introduce-registers-for-instruction
   mir))
