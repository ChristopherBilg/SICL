(cl:in-package #:sicl-register-allocation)

(defun find-register-in-arrangement (arrangement location)
  (multiple-value-bind (register-number stack-slot)
      (arr:find-attribution arrangement location)
    (cond
      ((not (null register-number))
       register-number)
      ;; Try to make a useful error...
      ((not (null stack-slot))
       (error "~s has an attributed stack slot but no attributed register.
Did you forget to call ENSURE-INPUT-AVAILABLE?"
              location))
      (t
       (error "~s has no attribution." location)))))

(defgeneric introduce-registers-for-instruction (instruction))

;;; For most instructions, it suffices to replace every lexical
;;; location with the registers attributed to them.
(defmethod introduce-registers-for-instruction
    ((instruction cleavir-ir:instruction))
  (setf (cleavir-ir:inputs instruction)
        (mapcar (lambda (input)
                  (find-register-in-arrangement (input-arrangement instruction)
                                                input))
                (cleavir-ir:inputs instruction)))
  (setf (cleavir-ir:outputs instruction)
        (mapcar (lambda (output)
                  (find-register-in-arrangement (output-arrangement instruction)
                                                output))
                (cleavir-ir:outputs instruction))))

;;; The most common exceptions to the former rule are assignments
;;; generated by SPILL and UNSPILL.

(defun introduce-registers (mir)
  (cleavir-ir:map-instructions-arbitrary-order
   #'introduce-registers-for-instruction
   mir))
