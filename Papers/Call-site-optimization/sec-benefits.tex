\section{Benefits of our technique}
\label{sec-benefits}

Our technique makes possible several features that are not possible
when a function call is created by the caller, without knowledge
about the callee.

For starters, at least one indirection can be avoided, thereby saving
a memory access.  When the call is generated by the caller, there must
be an indirection through some kind of \emph{function cell}, unless the
callee is a function that is known never to change.  This indirection
is required so that a redefinition of the callee is taken into account
by the next call.  A typical \commonlisp{} implementation uses a
symbol (the name of the function) for this indirection, whereas
\sicl{} uses a separate \texttt{cons} cell, but the cost is the same.
With our technique, when a callee is altered, the snippet is
modified.  As a result, no indirection%
\footnote{Though, the snippet is itself a kind of indirection, of course.}
is required.  Furthermore, in
\sicl{} all functions are standard objects, which requires another
indirection from the \emph{header object} to the so-called \emph{rack}
where the entry point is stored.

A more significant benefit than saving an indirection is that argument
parsing can be greatly simplified.  Even in the simple case where all
parameters are required, it is no longer necessary for the caller to
pass the argument count, nor for the callee to check that it
corresponds to the number of parameters.  But the advantages are even
greater in the presence of optional parameters and in particular for
keyword parameters.  In a typical call with keyword parameters, the
keywords are literals.  The argument list can then be parsed once and
for all when the snippet is created, and the arguments can be directly
copied to the locations required by the callee.  This possibility
largely eliminates the need for separate compiler macros, as the
purpose of a compiler macro is precisely to take advantage of some
known structure of the list of argument, in order to substitute a call
to a specialized version of the callee.

The specialized function call can admit unboxed arguments.  Avoiding
boxing is particularly useful for applications that manipulate
floating-point values that are at least the size of the machine word,
say IEEE double or quadruple floats in a 64-bit system.  When a
general-purpose function-call protocol is used, each such argument
must be encapsulated in a memory-allocated object before the call, and
often, the argument will immediately be unboxed by the callee for
further processing.

Return values benefit from the same advantages as arguments.  Often,
the number of values required by the caller is known statically.  The
callee can then specialize the transfer of those values to the right
locations in the caller.  And if the caller requires fewer values than
the callee computes, the callee can sometimes be specialized so that
extraneous return values do not need to be computed at all.  As with
arguments, return values can be unboxed, again avoiding costly memory
allocations.

When the callee is a generic function, a specialized discriminating
function can often be created, provided that enough type information
is made available by the caller for the arguments that correspond to
specializers of some methods of the generic function.  In the extreme
(but common) case where the callee is a slot accessor and the class of
the specialized argument is known, the snippet can contain the full
code to access the slot, without any need to call a particular method
function.

Often, \emph{inlining} is used to improve the performance of function
calls, either by the application programmer or by the system itself.
But inlining some function necessarily increases the code size of each
caller of that function.  Furthermore, the semantics of inlining are
such that the caller must be recompiled for a modified callee to be
taken into account.  Our technique can often provide enough
performance improvement to make inlining unnecessary.  Total code size
will then be smaller, and the disadvantage of inlining with respect to
callee redefinition is eliminated.

Compared to the so-called \emph{ctor} technique describe in
\refSec{sec-previous-ctors}, our technique is more general, since it
does not involve any source-code transformations.  Thus, it can be
used with functions defined by the application programmer, and that
can change at any point after the callee has been compiled.
Furthermore, the \emph{ctor} technique still requires at least one,
probably two, indirections (one to access the funcallable object and
another one to access the entry point).  However, our technique in
itself can of course not accomplish the entire optimization machinery
required to optimize a function such as \texttt{make-instance}, as
knowledge of its semantics is required for such optimization.

%%  LocalWords:  inlining callee specializers accessor unboxed ctor
%%  LocalWords:  ctors funcallable indirections
