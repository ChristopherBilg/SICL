\section{Our technique}
\label{sec-our-technique}

We define several \clos{}-based protocols for accessing and augmenting
lexical environment.  This protocol is defined and implemented in the
\trucler{} library.%
\footnote{https://github.com/s-expressionists/Trucler}

\subsection{Querying the environment}
\label{querying-the-environment}

A language processor calls one of the query functions in order to
determine the nature of a language element, depending on the position
in source code of that language element.  All these functions are
generic, and they all take a \texttt{client} parameter and an
\texttt{environment} parameter.  Methods defined by \trucler{} do not
specialize to the \texttt{client} parameter.  Client code should pass
an object specific to the application as a value of that parameter,
and it can supply methods specialized to the class of this object, for
the purpose of extending or overriding default behavior.  The
\texttt{environment} parameter is an object of the type used by the
implementation that \trucler{} is configured for.  Functions that are
used to query a particular \emph{name} have an additional parameter
for this purpose.

The following query functions are defined by \trucler{}.  Each one
returns an instance of a class that allows the language processor to
determine the exact nature of the language element (\texttt{nil} is
returned if there is no definition for the element), for example by
using the instance in a call to a generic function:

\begin{itemize}
\item \texttt{describe-variable}.  This function returns an instance
  of a class that distinguishes lexical variables, special variables,
  constant variables, and symbol macros.
\item \texttt{describe-function}.  This function returns an instance
  of a class that distinguishes global functions, local functions, and
  macros.
\item \texttt{describe-block}.
\item \texttt{describe-tag}.
\item \texttt{describe-optimize}.
\item \texttt{describe-declarations}.  This function is called by the
  language processor in order to determine the declaration identifiers
  of \texttt{declaration} proclamations.
\end{itemize}

\subsection{Augmenting the environment}

A language processor calls one of the augmentation functions in order
to define a lexical environment within the scope of a declaration or a
definition encountered in source code.  All these functions take at
least a \texttt{client} parameter and an \texttt{environment}
parameter just like the query functions, and they all return a new
lexical environment, augmented according to the function being called.

The following functions are called by the language processor when a
local definition is encountered, and they return a new environment that
includes the new definition:

\begin{itemize}
\item \texttt{add-lexical-variable}.
\item \texttt{add-special-variable}.
\item \texttt{add-local-symbol-macro}.
\item \texttt{add-local-function}.
\item \texttt{add-local-macro}.
\item \texttt{add-block}.
\item \texttt{add-tag}.
\end{itemize}

The following functions are called by the language processor as the
result of a local declaration that restricts an existing local
function or variable:

\begin{itemize}
\item \texttt{add-variable-type}.
\item \texttt{add-variable-ignore}.
\item \texttt{add-variable-dynamic-extent}.
\item \texttt{add-function-type}.
\item \texttt{add-function-ignore}.
\item \texttt{add-function-dynamic-extent}.
\end{itemize}

The following functions are called by the language processor as the
result of a local \texttt{optimize} declaration.

\begin{itemize}
\item \texttt{add-inline}.
\item \texttt{add-speed}.
\item \texttt{add-compilation-speed}.
\item \texttt{add-debug}.
\item \texttt{add-safety}.
\item \texttt{add-space}.
\end{itemize}

\subsection{The reference implementation}

\trucler{} supports some existing \commonlisp{} implementations as
described in \refSec{trucler-supported-implementations}, but it also
comes with a \emph{reference implementation} that can be used by a new
\commonlisp{} implementation that does not have its own representation
of lexical environments.  The reference implementation is used by
\sicl{}%
\footnote{https://github.com/robert-strandh/SICL} for instance.

In the reference implementation, a lexical environment is represented
as a standard object containing a slot for each type of description to
be returned by a query function as described in
\refSec{querying-the-environment}.  Each slot contains a list of
descriptions ordered from innermost to outermost.  A query function
merely return the first item on the list that matches the name that
was passed as an argument to the query function.  As a direct
consequence of this representation, there is no performance penalty in
the query functions, due to the fact that a new environment is created
for every call to an augmentation function.

In order to create new objects such as environments or descriptions,
we use a technique that we call \emph{quasi cloning}.  A generic
function named \texttt{cloning-information} is called with the
original object as an argument.  This function then returns a list of
pairs.  The first element of the pair is a slot initialization argument
for the class of the object and the second element of the pair is the
name of a slot reader for the same slot.  This information is then
used to access slots in the original object and to pass that
information as an initialization argument to \texttt{make-instance}.
We call it quasi cloning, because some new value is prepended to the
initialization arguments so that the copy is like the original, except
for one slot.

\subsection{Supported \commonlisp{} implementations}
\label{trucler-supported-implementations}

\trucler{} currently provides support for \sbcl{} and \ccl{}.
Contributions for other \commonlisp{} implementations are welcome.
With these implementations, it is possible to write code walkers that
are portable across different \commonlisp{} implementations.  In
particular, a \cleavir{}-based compiler can compile source code for
any of the supported implementations.
