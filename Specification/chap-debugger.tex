\chapter{Debugger}
\label{chap-debugger}

Part of the reason for \sysname{} is to have a system that provides
excellent debugging facilities for the programmer.  The kind of
debugger we plan to support is described in a separate repository.%
\footnote{See https://github.com/robert-strandh/Clordane}  In this
chapter, we describe only the support that \sysname{} contains in
order to make such a debugger possible.

Each function contains two versions of the code, called the
\emph{normal} version and the \emph{debugging} version.%
\footnote{This idea was suggested by Michael Raskin.}
Calls from the normal version of a caller are made to the normal version
of callees, and calls from the debugging version of a caller are made to
the debugging version of callees.

The normal version is used when the thread is not run under the
control of the debugger, so this version does not contain any code for
communicating with the debugger.  Furthermore, this version is highly
optimized.  In particular, variables that occur in the source code may
have been eliminated by various optimization passes.

In the debugging version of a function, the compiler associates
additional code with the program point immediately preceding the
evaluation of a form and with the program point immediately following
the evaluation of a form.  This code consists of a sequence of
instructions that consult a \emph{dictionary}%
\footnote{Different implementations for the dictionary are possible,
  like a hash table or a sorted vector of values of the program
  counter.}
in the thread object to determine whether this thread has a breakpoint
associated with the program point, and if so, gives up control to the
debugger.  This additional code is immediately preceded by an
unconditional \texttt{jump} instruction that normally contains the
address of the end of the additional code, so that the additional code
is never executed.  When a breakpoint is set at some program point,
the target field of the unconditional jump instruction is altered so
that it instead contains the address of its own successor.  As a
result the additional code is then executed.

The debugging version does not have optimizations applied to it that
may make debugging harder.  Lexical variables that appear in source
code may be kept, or code may be included that can compute their
values from the lexical variables that \emph{are} kept, for the
duration of their scope.

%% For each possible breakpoint, the system must keep a description of
%% the lexical environment.  This includes mappings from variable names
%% to registers or stack locations, information about liveness of
%% registers and stack location, how a variable is stored in a location
%% (immediate value, pointer, with or without type tag, etc).

